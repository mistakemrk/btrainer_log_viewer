### リファクタリング計画: btrainer_log_viewer

**目的:** アプリケーションの保守性と拡張性を向上させるため、関心の分離、ディレクトリ構造の整理、ログ解析ロジックの分離、状態管理の導入、UIのコンポーネント化を実施する。

**作業原則:**
*   既存の動作や機能に一切変更を加えない。
*   各ステップで動作確認を行い、問題があればすぐに前のステップに戻せるようにする。
*   プロジェクトの既存のコーディング規約とスタイルを尊重する。

---

**ステップ 1: 初期セットアップとベースラインの確立**

1.  **プロジェクトのビルドと実行確認:**
    *   現在のプロジェクトが問題なくビルドされ、実行できることを確認します。
    *   アプリケーションの主要な機能（ログの読み込み、地図表示、データサマリーなど）が正常に動作することを手動で確認し、ベースラインとします。
2.  **既存テストの確認と実行:**
    *   `test/` ディレクトリ以下の既存のテスト（`widget_test.dart`, `models/track_data_test.dart` など）を確認し、実行します。
    *   全てのテストがパスすることを確認し、リファクタリング中の回帰テストの基準とします。
    *   もしテストが存在しない場合、このステップではテストの追加は行わず、以降のステップで手動での厳密な動作確認を重視します。
3.  **新規ディレクトリ構造の作成:**
    *   `lib/` ディレクトリ直下に以下のディレクトリを作成します。
        *   `lib/services/`
        *   `lib/viewmodels/`
        *   `lib/views/`
        *   `lib/views/widgets/`

**ステップ 2: テストカバレッジの向上**

1.  **ユニットテストの追加:**
    *   **NMEAパーサー (`utils/nmea_parser.dart`) のテスト:**
        *   [ ] `calculateNMEAChecksum`: 正しいNMEAセンテンスから期待されるチェックサムが計算されることをテストする。
        *   [ ] 各種NMEAセンテンスのパース処理: 正しいフォーマットの文字列からデータオブジェクトが生成されること、不正なフォーマットで `null` が返ることをテストする。
    *   **位置情報・計算ロジック (`main.dart` 内) のテスト:**
        *   [ ] `_convertNmeaToDecimal`: 各方位（N/S/E/W）で正しく10進数に変換されることをテストする。
        *   [ ] `_calculateDistance`: 既知の2点間の距離が正しく計算されることをテストする。
        *   [ ] `_calculateZoomLevel`: 特定の緯度経度範囲に対して適切なズームレベルが計算されることをテストする。
    *   **データモデル (`models/track_data.dart`) のテスト:**
        *   [ ] `points` が空の場合の各プロパティの初期値を確認するテストを追加する。

2.  **ウィジェットテストの追加:**
    *   **`MyHomePage` の状態変化テスト:**
        *   [ ] `FilePicker` をモック化し、ログファイル読み込み後のUI（AppBarのサブタイトル、地図上のPolyline/Marker）が正しく更新されることをテストする。
        *   [ ] 空または不正なファイルを読み込んだ場合に、UIがクラッシュせず初期状態を維持することをテストする。
    *   **地図の表示/非表示機能のテスト:**
        *   [ ] 表示切り替えボタンのタップで `TileLayer` の表示/非表示が切り替わること、ボタンアイコンが変化することをテストする。

3.  **インテグレーションテストの追加:**
    *   **ファイル読み込みから表示までのE2Eテスト:**
        *   [ ] アプリ起動からファイル選択、地図と情報が表示されるまでの一連の流れをテストする。
        *   [ ] データを表示した後に別のファイルを読み込むと、表示が正しく更新されることをテストする。

4.  **動作確認:**
    *   追加した全てのテストを実行し、パスすることを確認します。
    *   アプリケーションを手動で実行し、既存の機能に影響がないことを確認します。

**ステップ 3: ログ解析ロジックの分離**

1.  **`LogParserService` クラスの作成:**
    *   `lib/services/log_parser_service.dart` ファイルを作成します。
    *   `main.dart` 内のログ解析に関連するロジック（例: NMEAデータのパース、トラックデータの生成など）を `LogParserService` クラスに移動します。
    *   `LogParserService` は純粋なビジネスロジックのみを扱い、UIや状態管理には依存しないようにします。
2.  **`main.dart` の修正:**
    *   `main.dart` から移動したログ解析ロジックを削除し、新しく作成した `LogParserService` を利用するように修正します。
3.  **動作確認:**
    *   アプリケーションをビルドし、実行します。
    *   ログファイルの読み込み、解析、表示が以前と同様に機能することを確認します。
    *   既存のテストを実行し、パスすることを確認します。

**ステップ 4: ViewModel と基本的な状態管理の導入**

1.  **`LogViewerViewModel` クラスの作成:**
    *   `lib/viewmodels/log_viewer_viewmodel.dart` ファイルを作成します。
    *   `ChangeNotifier` を継承した `LogViewerViewModel` クラスを定義します。
    *   `main.dart` 内のアプリケーションの状態（例: `_trackData`, `_workoutData` など）と、それらの状態を変更するロジック（例: ファイル選択後のデータ更新処理）を `LogViewerViewModel` に移動します。
    *   `LogParserService` のインスタンスを `LogViewerViewModel` 内で利用するようにします。
2.  **`main.dart` の修正:**
    *   `main.dart` から移動した状態変数とロジックを削除します。
    *   `main.dart` の `MyApp` ウィジェットで `ChangeNotifierProvider` を使用して `LogViewerViewModel` を提供するように設定します。
    *   `main.dart` 内で `setState` を直接呼び出している箇所を、`LogViewerViewModel` のメソッド呼び出しや `Consumer` ウィジェットの使用に置き換えます。
3.  **動作確認:**
    *   アプリケーションをビルドし、実行します。
    *   ログファイルの読み込み、データ表示、UIの更新が `setState` に依存せず、`LogViewerViewModel` を介して正常に機能することを確認します。
    *   既存のテストを実行し、パスすることを確認します。

**ステップ 5: UI のコンポーネント化 - ホーム画面**

1.  **`HomeScreen` ウィジェットの作成:**
    *   `lib/views/home_screen.dart` ファイルを作成します。
    *   `main.dart` の `_MyHomePageState` クラスの `build` メソッド内の主要なUI構造（`Scaffold`, `AppBar`, `Column` など）を `HomeScreen` ウィジェットに移動します。
    *   `HomeScreen` は `LogViewerViewModel` を `Provider.of` または `Consumer` を介して利用し、データを表示し、ユーザーインタラクションを処理します。
2.  **`main.dart` の修正:**
    *   `main.dart` の `_MyHomePageState` クラスからUI構築ロジックを削除し、`HomeScreen` ウィジェットを表示するように修正します。
3.  **動作確認:**
    *   アプリケーションをビルドし、実行します。
    *   UIのレイアウトと機能が以前と全く同じであることを確認します。
    *   既存のテストを実行し、パスすることを確認します。

**ステップ 6: UI のコンポーネント化 - 個別ウィジェット**

1.  **個別ウィジェットの特定と作成:**
    *   `HomeScreen` 内で、地図表示、データサマリーパネル、ファイル選択ボタンなど、独立した機能を持つUIコンポーネントを特定します。
    *   それぞれのコンポーネントに対応する新しいウィジェットファイル（例: `lib/views/widgets/map_display_widget.dart`, `lib/views/widgets/data_summary_widget.dart` など）を作成します。
    *   `lib/widgets/track_map.dart` は既存のウィジェットなので、必要に応じて `lib/views/widgets/` に移動または参照を調整します。
2.  **UIコードの移動:**
    *   特定したUIコンポーネントのコードを、それぞれの新しいウィジェットファイルに移動します。
    *   これらのウィジェットは、必要に応じて `LogViewerViewModel` からデータを取得し、イベントを通知するようにします。
3.  **`HomeScreen` の修正:**
    *   `HomeScreen` から移動したUIコードを削除し、新しく作成した個別ウィジェットを組み込むように修正します。
4.  **動作確認:**
    *   アプリケーションをビルドし、実行します。
    *   全てのUIコンポーネントが正しく表示され、機能することを確認します。
    *   既存のテストを実行し、パスすることを確認します。

**ステップ 7: クリーンアップと最終検証**

1.  **コードの整理:**
    *   `main.dart` から不要になったインポート、変数、メソッドを全て削除します。
    *   新しく作成したファイルや移動したファイルで、不要なコメントやデバッグコードを削除します。
    *   各ファイルで適切なインポート文が使用されていることを確認します。
2.  **プロジェクト全体の動作確認:**
    *   アプリケーション全体をビルドし、実行します。
    *   全ての機能が期待通りに動作し、UIに問題がないことを徹底的に確認します。
3.  **リンティングとフォーマットの実行:**
    *   プロジェクトのリンティングツール（例: `flutter analyze`）とフォーマッター（例: `flutter format .`）を実行し、コードスタイルが統一されていることを確認します。
    *   警告やエラーがないことを確認します。
4.  **最終テストの実行:**
    *   全ての既存テストを再度実行し、パスすることを確認します。

---

### 新しいルール: アプリケーションのタイトルに現在のステップを表示する

*   各リファクタリングステップの開始時、アプリケーションのタイトル（例: `AppBar` のタイトル）に現在のステップ番号と簡単な説明を追記します。
    *   例: `B-Trainer Log Viewer (Step 1)`
*   これにより、ユーザーはビルドされたアプリケーションがどのリファクタリングステップの状態にあるかを視覚的に確認できます。
*   この変更は、テストの整合性を保つために、関連するウィジェットテストも同時に更新する必要があります。ステップ番号がずれるため、各ステップでのタイトルも `(Step 2)`, `(Step 3)`... のように変更されます。

---

### 新しいルール: 各ステップの作業計画

*   各リファクタリングステップを開始する前に、まず `docs/` ディレクトリ内に対応するステップの計画書（例: `refactoring_step2_plan.md`）が存在するかを確認します。
*   **計画書が存在する場合:** その計画書に記載されている手順に従って作業を進めます。
*   **計画書が存在しない場合:** `GEMINI.md` の概要に基づいて、そのステップで実施する具体的な作業計画をユーザーに提案し、合意を得てから `docs/` ディレクトリに計画書（Markdown形式）を作成します。その後、作成した計画書に従って作業を進めます。
